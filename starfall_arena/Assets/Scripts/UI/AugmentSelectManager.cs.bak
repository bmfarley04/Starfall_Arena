using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;
using TMPro;

namespace StarfallArena.UI
{
    /// <summary>
    /// Manages the augment selection screen with tier-based random selection,
    /// animated UI transitions, and controller navigation support.
    /// </summary>
    public class AugmentSelectManager : MonoBehaviour
    {
        [Header("Augment Pools")]
        [Tooltip("Tier 1 augments (common)")]
        [SerializeField] private List<Augment> tier1Augments = new List<Augment>();

        [Tooltip("Tier 2 augments (rare)")]
        [SerializeField] private List<Augment> tier2Augments = new List<Augment>();

        [Tooltip("Tier 3 augments (legendary)")]
        [SerializeField] private List<Augment> tier3Augments = new List<Augment>();

        [Header("Tier Selection Probabilities")]
        [Tooltip("Probability of tier 1 appearing (must sum to 1 with other tiers)")]
        [Range(0f, 1f)]
        [SerializeField] private float tier1Probability = 0.6f;

        [Tooltip("Probability of tier 2 appearing (must sum to 1 with other tiers)")]
        [Range(0f, 1f)]
        [SerializeField] private float tier2Probability = 0.3f;

        [Tooltip("Probability of tier 3 appearing (must sum to 1 with other tiers)")]
        [Range(0f, 1f)]
        [SerializeField] private float tier3Probability = 0.1f;

        [Header("Tier 1 UI References - Choice 1")]
        [SerializeField] private Image tier1Choice1Icon;
        [SerializeField] private TextMeshProUGUI tier1Choice1Name;
        [SerializeField] private TextMeshProUGUI tier1Choice1Description;

        [Header("Tier 1 UI References - Choice 2")]
        [SerializeField] private Image tier1Choice2Icon;
        [SerializeField] private TextMeshProUGUI tier1Choice2Name;
        [SerializeField] private TextMeshProUGUI tier1Choice2Description;

        [Header("Tier 1 UI References - Choice 3")]
        [SerializeField] private Image tier1Choice3Icon;
        [SerializeField] private TextMeshProUGUI tier1Choice3Name;
        [SerializeField] private TextMeshProUGUI tier1Choice3Description;

        [Header("Tier 2 UI References - Choice 1")]
        [SerializeField] private Image tier2Choice1Icon;
        [SerializeField] private TextMeshProUGUI tier2Choice1Name;
        [SerializeField] private TextMeshProUGUI tier2Choice1Description;

        [Header("Tier 2 UI References - Choice 2")]
        [SerializeField] private Image tier2Choice2Icon;
        [SerializeField] private TextMeshProUGUI tier2Choice2Name;
        [SerializeField] private TextMeshProUGUI tier2Choice2Description;

        [Header("Tier 2 UI References - Choice 3")]
        [SerializeField] private Image tier2Choice3Icon;
        [SerializeField] private TextMeshProUGUI tier2Choice3Name;
        [SerializeField] private TextMeshProUGUI tier2Choice3Description;

        [Header("Tier 3 UI References - Choice 1")]
        [SerializeField] private Image tier3Choice1Icon;
        [SerializeField] private TextMeshProUGUI tier3Choice1Name;
        [SerializeField] private TextMeshProUGUI tier3Choice1Description;

        [Header("Tier 3 UI References - Choice 2")]
        [SerializeField] private Image tier3Choice2Icon;
        [SerializeField] private TextMeshProUGUI tier3Choice2Name;
        [SerializeField] private TextMeshProUGUI tier3Choice2Description;

        [Header("Tier 3 UI References - Choice 3")]
        [SerializeField] private Image tier3Choice3Icon;
        [SerializeField] private TextMeshProUGUI tier3Choice3Name;
        [SerializeField] private TextMeshProUGUI tier3Choice3Description;

        [Header("Canvas Groups")]
        [Tooltip("Canvas group containing tier 1 UI")]
        [SerializeField] private CanvasGroup tier1CanvasGroup;

        [Tooltip("Canvas group containing tier 2 UI")]
        [SerializeField] private CanvasGroup tier2CanvasGroup;

        [Tooltip("Canvas group containing tier 3 UI")]
        [SerializeField] private CanvasGroup tier3CanvasGroup;

        [Header("Card Buttons (3 per tier — left, center, right)")]
        [SerializeField] private Button[] tier1Buttons = new Button[3];
        [SerializeField] private Button[] tier2Buttons = new Button[3];
        [SerializeField] private Button[] tier3Buttons = new Button[3];

        [Header("Hover / Selection Scale")]
        [Tooltip("X scale multiplier when a card is hovered/selected")]
        [SerializeField] private float hoverScaleX = 1.1f;
        [Tooltip("Y scale multiplier when a card is hovered/selected")]
        [SerializeField] private float hoverScaleY = 1.1f;
        [Tooltip("Duration of the hover scale transition")]
        [SerializeField] private float hoverScaleDuration = 0.12f;

        [Header("Player Choice UI")]
        [Tooltip("Text field showing which player is choosing (e.g. 'PLAYER 1 CHOICE')")]
        [SerializeField] private TextMeshProUGUI playerChoiceText;
        [Tooltip("Countdown timer text field")]
        [SerializeField] private TextMeshProUGUI countdownTimerText;
        [Tooltip("Time in seconds for each player to pick an augment")]
        [SerializeField] private float selectionTimeLimit = 10f;
        [Tooltip("Color for Player 1 choice text and timer")]
        [SerializeField] private Color player1Color = Color.cyan;
        [Tooltip("Color for Player 2 choice text and timer")]
        [SerializeField] private Color player2Color = Color.red;

        [Header("Animation Settings")]
        [Tooltip("Duration of the entrance animation")]
        [SerializeField] private float animationDuration = 0.6f;

        [Tooltip("Animation curve for entrance (bounce/overshoot recommended)")]
        [SerializeField] private AnimationCurve entranceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

        [Tooltip("Starting scale for cards (0 = from center point)")]
        [SerializeField] private float startScale = 0f;

        [Tooltip("Delay between each card animation")]
        [SerializeField] private float cardAnimationDelay = 0.1f;

        [Header("Audio")]
        [Tooltip("Sound played when augment screen appears")]
        [SerializeField] private SoundEffect augmentAppearSound;

        [Tooltip("AudioSource for playing UI sounds (2D)")]
        [SerializeField] private AudioSource audioSource;

        [Header("Debug")]
        [Tooltip("Automatically show augment select on Start (for testing)")]
        [SerializeField] private bool debugShowOnStart = false;

        [Tooltip("Enable F1 key to trigger augment select during play (for testing)")]
        [SerializeField] private bool debugEnableKeyTrigger = true;

        // ===== EVENTS =====
        /// <summary>
        /// Fired when a player selects an augment. Parameters: chosen augment, choice index (0-2).
        /// </summary>
        public System.Action<Augment, int> onAugmentChosen;

        // Internal state
        private int currentTier;
        private int currentPickingPlayer; // 1 or 2
        private List<Augment> selectedAugments = new List<Augment>(3);
        private bool isShowing = false;
        private List<Augment> _overridePool = null;
        private Coroutine _countdownCoroutine;

        // Hover state — tracks original scales per card button so we restore correctly
        private Dictionary<Button, Vector3> _cardOriginalScales = new Dictionary<Button, Vector3>();
        private Dictionary<Button, Coroutine> _hoverCoroutines = new Dictionary<Button, Coroutine>();

        private void OnValidate()
        {
            // Warn if probabilities don't sum to 1
            float sum = tier1Probability + tier2Probability + tier3Probability;
            if (Mathf.Abs(sum - 1f) > 0.001f)
            {
                Debug.LogWarning($"Tier probabilities sum to {sum:F3}, but should sum to 1.0");
            }
        }

        private void Start()
        {
            // Hide all tiers at start
            HideAllTiers();

            // Wire button onClick events + hover listeners for all tiers
            WireButtonEvents(tier1Buttons);
            WireButtonEvents(tier2Buttons);
            WireButtonEvents(tier3Buttons);

            // Debug: Auto-show if enabled
            if (debugShowOnStart)
            {
                ShowAugmentSelect(1);
            }
        }

        private void Update()
        {
            // Debug: Trigger with F1 key press (new Input System)
            if (debugEnableKeyTrigger && !isShowing)
            {
                if (Keyboard.current != null && Keyboard.current.f1Key.wasPressedThisFrame)
                {
                    ShowAugmentSelect(1);
                }
            }
        }

        // ===== BUTTON WIRING =====

        /// <summary>
        /// Wires onClick and select/deselect listeners for a set of 3 card buttons.
        /// </summary>
        private void WireButtonEvents(Button[] buttons)
        {
            if (buttons == null) return;

            for (int i = 0; i < buttons.Length; i++)
            {
                if (buttons[i] == null) continue;

                int index = i; // capture for closure
                Button btn = buttons[i];

                // onClick → select this augment
                btn.onClick.AddListener(() => OnAugmentSelected(index));

                // Add EventTrigger for Select / Deselect (controller navigation)
                EventTrigger trigger = btn.gameObject.GetComponent<EventTrigger>();
                if (trigger == null)
                    trigger = btn.gameObject.AddComponent<EventTrigger>();

                // On Select (hovered via controller)
                EventTrigger.Entry selectEntry = new EventTrigger.Entry { eventID = EventTriggerType.Select };
                selectEntry.callback.AddListener(_ => OnCardHoverEnter(btn));
                trigger.triggers.Add(selectEntry);

                // On Deselect (moved away via controller)
                EventTrigger.Entry deselectEntry = new EventTrigger.Entry { eventID = EventTriggerType.Deselect };
                deselectEntry.callback.AddListener(_ => OnCardHoverExit(btn));
                trigger.triggers.Add(deselectEntry);

                // On Pointer Enter (mouse fallback)
                EventTrigger.Entry pointerEnter = new EventTrigger.Entry { eventID = EventTriggerType.PointerEnter };
                pointerEnter.callback.AddListener(_ =>
                {
                    if (EventSystem.current != null)
                        EventSystem.current.SetSelectedGameObject(btn.gameObject);
                });
                trigger.triggers.Add(pointerEnter);
            }
        }

        // ===== HOVER SCALE =====

        private void OnCardHoverEnter(Button btn)
        {
            if (btn == null) return;

            if (!_cardOriginalScales.ContainsKey(btn))
                _cardOriginalScales[btn] = btn.transform.localScale;

            Vector3 target = new Vector3(
                _cardOriginalScales[btn].x * hoverScaleX,
                _cardOriginalScales[btn].y * hoverScaleY,
                _cardOriginalScales[btn].z
            );

            if (_hoverCoroutines.ContainsKey(btn) && _hoverCoroutines[btn] != null)
                StopCoroutine(_hoverCoroutines[btn]);

            _hoverCoroutines[btn] = StartCoroutine(LerpScale(btn.transform, target, hoverScaleDuration));
        }

        private void OnCardHoverExit(Button btn)
        {
            if (btn == null) return;

            if (!_cardOriginalScales.ContainsKey(btn)) return;

            if (_hoverCoroutines.ContainsKey(btn) && _hoverCoroutines[btn] != null)
                StopCoroutine(_hoverCoroutines[btn]);

            _hoverCoroutines[btn] = StartCoroutine(LerpScale(btn.transform, _cardOriginalScales[btn], hoverScaleDuration));
        }

        private IEnumerator LerpScale(Transform t, Vector3 target, float duration)
        {
            Vector3 start = t.localScale;
            float elapsed = 0f;
            while (elapsed < duration)
            {
                elapsed += Time.unscaledDeltaTime;
                t.localScale = Vector3.Lerp(start, target, Mathf.Clamp01(elapsed / duration));
                yield return null;
            }
            t.localScale = target;
        }

        // ===== SHOW / HIDE =====

        /// <summary>
        /// MAIN FUNCTION: Call this from your scene manager to show the augment select screen.
        /// </summary>
        /// <param name="pickingPlayer">Which player is picking (1 or 2). Used for UI text + color.</param>
        [ContextMenu("Debug: Show Augment Select")]
        public void ShowAugmentSelect(int pickingPlayer = 1)
        {
            if (isShowing)
            {
                Debug.LogWarning("Augment select is already showing!");
                return;
            }

            isShowing = true;
            currentPickingPlayer = pickingPlayer;

            // Select tier based on probabilities
            currentTier = SelectRandomTier();
            Debug.Log($"Selected augment tier: {currentTier}");

            // Use override pool if provided, otherwise pick randomly from tier
            if (_overridePool != null && _overridePool.Count > 0)
            {
                selectedAugments = new List<Augment>(_overridePool);
                _overridePool = null;
            }
            else
            {
                selectedAugments = SelectRandomAugments(currentTier);
            }

            // Populate UI with selected augments
            PopulateUI(currentTier, selectedAugments);

            // Update player choice text and colors
            UpdatePlayerChoiceUI(pickingPlayer);

            // Show only the selected tier's canvas group (activates GameObject)
            // Cards start invisible — the animation reveals them
            ShowTierCanvas(currentTier);

            // Play entrance animation
            StartCoroutine(AnimateEntrance(currentTier));

            // Start countdown timer
            if (_countdownCoroutine != null) StopCoroutine(_countdownCoroutine);
            _countdownCoroutine = StartCoroutine(RunCountdownTimer());

            // Play sound effect
            if (augmentAppearSound != null && audioSource != null)
            {
                augmentAppearSound.Play(audioSource);
            }
        }

        /// <summary>
        /// Shows the augment select screen with a specific pool of augments.
        /// Used by SceneManager for sequential 2-player augment selection.
        /// </summary>
        public void ShowAugmentSelectWithPool(List<Augment> pool, int pickingPlayer = 1)
        {
            _overridePool = pool;
            ShowAugmentSelect(pickingPlayer);
        }

        /// <summary>
        /// Returns the list of currently selected augments (for removing chosen augment from pool).
        /// </summary>
        public List<Augment> GetSelectedAugments()
        {
            return selectedAugments;
        }

        /// <summary>
        /// Hides the augment select screen. Call this after an augment is chosen.
        /// </summary>
        public void HideAugmentSelect()
        {
            if (_countdownCoroutine != null)
            {
                StopCoroutine(_countdownCoroutine);
                _countdownCoroutine = null;
            }

            // Reset any hover scales
            foreach (var kvp in _cardOriginalScales)
            {
                if (kvp.Key != null)
                    kvp.Key.transform.localScale = kvp.Value;
            }
            _cardOriginalScales.Clear();

            HideAllTiers();
            isShowing = false;
        }

        // ===== PLAYER CHOICE UI =====

        private void UpdatePlayerChoiceUI(int playerNumber)
        {
            Color c = playerNumber == 1 ? player1Color : player2Color;

            if (playerChoiceText != null)
            {
                playerChoiceText.text = $"PLAYER {playerNumber} CHOICE";
                playerChoiceText.color = c;
            }

            if (countdownTimerText != null)
            {
                countdownTimerText.color = c;
                countdownTimerText.text = Mathf.CeilToInt(selectionTimeLimit).ToString();
            }
        }

        private IEnumerator RunCountdownTimer()
        {
            float remaining = selectionTimeLimit;

            while (remaining > 0f)
            {
                if (countdownTimerText != null)
                    countdownTimerText.text = Mathf.CeilToInt(remaining).ToString();

                remaining -= Time.unscaledDeltaTime;
                yield return null;
            }

            if (countdownTimerText != null)
                countdownTimerText.text = "0";

            // Time expired — auto-select the center augment (index 1) if available, else 0
            if (isShowing)
            {
                int autoIndex = selectedAugments.Count > 1 ? 1 : 0;
                Debug.Log($"[AugmentSelect] Time expired — auto-selecting augment index {autoIndex}");
                OnAugmentSelected(autoIndex);
            }

            _countdownCoroutine = null;
        }

        // ===== INTERNAL HELPERS =====

        /// <summary>
        /// Hides all tier canvas groups.
        /// </summary>
        private void HideAllTiers()
        {
            SetCanvasGroupVisibility(tier1CanvasGroup, false);
            SetCanvasGroupVisibility(tier2CanvasGroup, false);
            SetCanvasGroupVisibility(tier3CanvasGroup, false);
        }

        /// <summary>
        /// Selects a random tier based on the configured probabilities.
        /// </summary>
        private int SelectRandomTier()
        {
            float roll = Random.Range(0f, 1f);

            if (roll < tier1Probability)
            {
                return 1;
            }
            else if (roll < tier1Probability + tier2Probability)
            {
                return 2;
            }
            else
            {
                return 3;
            }
        }

        /// <summary>
        /// Selects 3 random augments from the specified tier without duplicates.
        /// </summary>
        private List<Augment> SelectRandomAugments(int tier)
        {
            List<Augment> sourceList = tier switch
            {
                1 => tier1Augments,
                2 => tier2Augments,
                3 => tier3Augments,
                _ => tier1Augments
            };

            if (sourceList.Count < 3)
            {
                Debug.LogError($"Tier {tier} has fewer than 3 augments! Cannot populate augment select.");
                return new List<Augment>();
            }

            // Create copy to avoid modifying original list
            List<Augment> availableAugments = new List<Augment>(sourceList);
            List<Augment> selected = new List<Augment>(3);

            // Pick 3 random augments without replacement
            for (int i = 0; i < 3; i++)
            {
                int randomIndex = Random.Range(0, availableAugments.Count);
                selected.Add(availableAugments[randomIndex]);
                availableAugments.RemoveAt(randomIndex);
            }

            return selected;
        }

        /// <summary>
        /// Populates the UI elements with the selected augments.
        /// </summary>
        private void PopulateUI(int tier, List<Augment> augments)
        {
            if (augments.Count < 3)
            {
                Debug.LogError("Not enough augments selected to populate UI!");
                return;
            }

            switch (tier)
            {
                case 1:
                    SetUIElements(tier1Choice1Icon, tier1Choice1Name, tier1Choice1Description, augments[0]);
                    SetUIElements(tier1Choice2Icon, tier1Choice2Name, tier1Choice2Description, augments[1]);
                    SetUIElements(tier1Choice3Icon, tier1Choice3Name, tier1Choice3Description, augments[2]);
                    break;

                case 2:
                    SetUIElements(tier2Choice1Icon, tier2Choice1Name, tier2Choice1Description, augments[0]);
                    SetUIElements(tier2Choice2Icon, tier2Choice2Name, tier2Choice2Description, augments[1]);
                    SetUIElements(tier2Choice3Icon, tier2Choice3Name, tier2Choice3Description, augments[2]);
                    break;

                case 3:
                    SetUIElements(tier3Choice1Icon, tier3Choice1Name, tier3Choice1Description, augments[0]);
                    SetUIElements(tier3Choice2Icon, tier3Choice2Name, tier3Choice2Description, augments[1]);
                    SetUIElements(tier3Choice3Icon, tier3Choice3Name, tier3Choice3Description, augments[2]);
                    break;
            }

            // Re-enable all card buttons (may have been disabled from previous pick)
            ReEnableCardButtons(tier);
        }

        /// <summary>
        /// Re-enables all card buttons for the given tier.
        /// </summary>
        private void ReEnableCardButtons(int tier)
        {
            Button[] buttons = GetButtonsForTier(tier);
            if (buttons == null) return;

            foreach (var btn in buttons)
            {
                if (btn != null)
                {
                    btn.interactable = true;
                    // Reset alpha in case it was dimmed
                    CanvasGroup cg = btn.GetComponent<CanvasGroup>();
                    if (cg != null) cg.alpha = 1f;
                }
            }
        }

        /// <summary>
        /// Sets the UI elements (icon, name, description) for a single augment choice.
        /// </summary>
        private void SetUIElements(Image icon, TextMeshProUGUI nameText, TextMeshProUGUI descriptionText, Augment augment)
        {
            if (icon != null)
            {
                icon.sprite = augment.icon;
            }

            if (nameText != null)
            {
                nameText.text = augment.augmentName;
            }

            if (descriptionText != null)
            {
                descriptionText.text = augment.description;
            }
        }

        /// <summary>
        /// Shows the canvas group for the selected tier, hides others.
        /// Cards start at scale 0 and alpha 0 — the entrance animation is the first time they appear.
        /// </summary>
        private void ShowTierCanvas(int tier)
        {
            // Hide all canvas groups first
            HideAllTiers();

            // Show selected tier
            CanvasGroup targetGroup = tier switch
            {
                1 => tier1CanvasGroup,
                2 => tier2CanvasGroup,
                3 => tier3CanvasGroup,
                _ => tier1CanvasGroup
            };

            if (targetGroup != null)
            {
                // Pre-hide all card children so they don't flash before animation
                int childCount = targetGroup.transform.childCount;
                for (int i = 0; i < childCount; i++)
                {
                    Transform child = targetGroup.transform.GetChild(i);
                    child.localScale = Vector3.one * startScale;

                    CanvasGroup childCG = child.GetComponent<CanvasGroup>();
                    if (childCG == null)
                        childCG = child.gameObject.AddComponent<CanvasGroup>();
                    childCG.alpha = 0f;
                }

                // Now activate the parent — cards are invisible (scale 0, alpha 0)
                targetGroup.gameObject.SetActive(true);
                targetGroup.alpha = 1f;
                targetGroup.interactable = false;
                targetGroup.blocksRaycasts = false;
            }
            else
            {
                Debug.LogError($"Tier {tier} canvas group is not assigned!");
            }
        }

        /// <summary>
        /// Sets a canvas group's visibility, interactability, and raycast blocking.
        /// </summary>
        private void SetCanvasGroupVisibility(CanvasGroup group, bool visible)
        {
            if (group == null) return;

            group.alpha = visible ? 1f : 0f;
            group.interactable = visible;
            group.blocksRaycasts = visible;

            if (!visible)
            {
                group.gameObject.SetActive(false);
            }
        }

        /// <summary>
        /// Animates the entrance of augment cards with staggered timing.
        /// </summary>
        private IEnumerator AnimateEntrance(int tier)
        {
            CanvasGroup targetGroup = tier switch
            {
                1 => tier1CanvasGroup,
                2 => tier2CanvasGroup,
                3 => tier3CanvasGroup,
                _ => tier1CanvasGroup
            };

            if (targetGroup == null)
            {
                Debug.LogError("Target canvas group is null!");
                yield break;
            }

            targetGroup.alpha = 1f;
            targetGroup.interactable = false;
            targetGroup.blocksRaycasts = false;

            // Get the three card transforms (first 3 children)
            Transform[] cardTransforms = new Transform[3];
            int childCount = Mathf.Min(3, targetGroup.transform.childCount);

            for (int i = 0; i < childCount; i++)
            {
                cardTransforms[i] = targetGroup.transform.GetChild(i);
            }

            // Animate each card with staggered timing
            for (int i = 0; i < cardTransforms.Length; i++)
            {
                if (cardTransforms[i] != null)
                {
                    StartCoroutine(AnimateCard(cardTransforms[i]));
                }
                yield return new WaitForSecondsRealtime(cardAnimationDelay);
            }

            // Wait for last animation to finish
            yield return new WaitForSecondsRealtime(animationDuration);

            // Enable interactability
            targetGroup.interactable = true;
            targetGroup.blocksRaycasts = true;

            // Cache original scales for hover system
            Button[] buttons = GetButtonsForTier(tier);
            if (buttons != null)
            {
                foreach (var btn in buttons)
                {
                    if (btn != null)
                        _cardOriginalScales[btn] = btn.transform.localScale;
                }
            }

            // Set default selection to center button (index 1)
            SetDefaultSelection(tier);
        }

        /// <summary>
        /// Animates a single card using scale and fade.
        /// </summary>
        private IEnumerator AnimateCard(Transform card)
        {
            CanvasGroup cardGroup = card.GetComponent<CanvasGroup>();
            if (cardGroup == null)
            {
                cardGroup = card.gameObject.AddComponent<CanvasGroup>();
            }

            // Target scale is 1 (the card's normal size)
            Vector3 targetScale = Vector3.one;
            float elapsed = 0f;

            while (elapsed < animationDuration)
            {
                elapsed += Time.unscaledDeltaTime;
                float t = elapsed / animationDuration;
                float curveValue = entranceCurve.Evaluate(t);

                // Scale animation
                card.localScale = Vector3.Lerp(Vector3.one * startScale, targetScale, curveValue);

                // Fade animation
                cardGroup.alpha = curveValue;

                yield return null;
            }

            // Ensure final state
            card.localScale = targetScale;
            cardGroup.alpha = 1f;
        }

        /// <summary>
        /// Sets the default EventSystem selection to the center button (index 1).
        /// </summary>
        private void SetDefaultSelection(int tier)
        {
            Button[] buttons = GetButtonsForTier(tier);
            Button defaultButton = (buttons != null && buttons.Length > 1 && buttons[1] != null)
                ? buttons[1]  // center button
                : null;

            if (defaultButton != null && EventSystem.current != null)
            {
                EventSystem.current.SetSelectedGameObject(defaultButton.gameObject);
            }
        }

        /// <summary>
        /// Returns the button array for the given tier.
        /// </summary>
        private Button[] GetButtonsForTier(int tier)
        {
            return tier switch
            {
                1 => tier1Buttons,
                2 => tier2Buttons,
                3 => tier3Buttons,
                _ => tier1Buttons
            };
        }

        /// <summary>
        /// Called when an augment is selected (via button click or controller confirm).
        /// </summary>
        public void OnAugmentSelected(int choiceIndex)
        {
            if (!isShowing) return;

            if (choiceIndex < 0 || choiceIndex >= selectedAugments.Count)
            {
                Debug.LogError($"Invalid augment choice index: {choiceIndex}");
                return;
            }

            Augment selectedAugment = selectedAugments[choiceIndex];
            Debug.Log($"Player {currentPickingPlayer} selected augment: {selectedAugment.augmentName}");

            // Stop countdown
            if (_countdownCoroutine != null)
            {
                StopCoroutine(_countdownCoroutine);
                _countdownCoroutine = null;
            }

            // Hide the augment select screen
            HideAugmentSelect();

            // Notify listeners (SceneManager) of the selection
            onAugmentChosen?.Invoke(selectedAugment, choiceIndex);
        }
    }
}
